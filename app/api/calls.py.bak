# app/api/calls.py
import os
import json
import requests
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Request, Response
from fastapi import Form
from pydantic import BaseModel
from sqlalchemy.orm import Session
from xml.sax.saxutils import escape as xml_escape

from app import db, models, schemas
from app.services import openai_client

import html


router = APIRouter(prefix="/api/calls", tags=["calls"])


def get_db():
    dbs = db.SessionLocal()
    try:
        yield dbs
    finally:
        dbs.close()


# --- Basic call CRUD endpoints (DB-only) ---
@router.post("/", response_model=schemas.CallOut)
def create_call(call_in: schemas.CallCreate, db_session: Session = Depends(get_db)):
    org = db_session.query(models.Organization).filter(models.Organization.id == call_in.org_id).first()
    if not org:
        raise HTTPException(status_code=400, detail="Organization not found")
    call = models.Call(
        org_id=call_in.org_id,
        patient_id=call_in.patient_id,
        status="queued",
        start_time=None,
    )
    db_session.add(call)
    db_session.commit()
    db_session.refresh(call)
    return call


@router.get("/{call_id}", response_model=schemas.CallOut)
def get_call(call_id: int, db_session: Session = Depends(get_db)):
    call = db_session.query(models.Call).filter(models.Call.id == call_id).first()
    if not call:
        raise HTTPException(status_code=404, detail="Call not found")
    return call


# --- TwiML endpoint: Twilio will GET/POST this to obtain TwiML for the outbound call ---
@router.api_route("/twiml/outbound/{call_id}", methods=["GET", "POST"])
async def twiml_outbound(call_id: int, request: Request, agent: Optional[str] = None):
    """
    Return TwiML XML for Twilio to execute when making an outbound call.
    Accepts both GET and POST (Twilio may use either).
    Agent can be provided via query param ?agent=... or as form field "agent".
    """
    # Query param takes precedence
    qs_agent = request.query_params.get("agent")
    if qs_agent:
        agent_name = qs_agent
        print("Ws me aaya"+ agent_name)
    else:
        agent_name = agent
        if request.method == "POST" and not agent_name:
            # attempt to read form body for 'agent' field
            try:
                print("Isme aaya")
                form = await request.form()
                if "agent" in form:
                    agent_name = form.get("agent")
            except Exception:
                agent_name = agent_name

    agent_name = agent_name or "annie_RPM"

    # Determine host Twilio used to request this TwiML (preserve ngrok or real domain)
    host = request.url.netloc  # includes host[:port]
    stream_url = f"wss://{host}/ws?agent={html.escape(agent_name)}&call_id={call_id}"
    stream_url_escaped = html.escape(stream_url, quote=True)
   # stream_url_escaped = xml_escape(stream_url, {'"': "&quot;"})
 #   pause_seconds = int(os.getenv("TWIML_PAUSE_SECONDS", "300"))

    twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Connect>
    <Stream url="{stream_url_escaped}"/>
  </Connect>
  <Say voice="alice">Thanks for your time. Goodbye.</Say>
  <Hangup/>
</Response>"""
    return Response(content=twiml, media_type="application/xml")


# --- Complete call: accept transcript, run OpenAI extraction, save readings ---
@router.post("/{call_id}/complete")
def complete_call(call_id: int, payload: dict, db_session: Session = Depends(get_db)):
    """
    Expected payload: {"transcript": "<text>", "duration_seconds": 123}
    Stores transcript, runs OpenAI to extract summary/readings, and saves readings to DB.
    """
    call = db_session.query(models.Call).filter(models.Call.id == call_id).first()
    if not call:
        raise HTTPException(status_code=404, detail="Call not found")

    transcript = payload.get("transcript", "")
    duration = payload.get("duration_seconds")
    call.transcript = transcript
    call.status = "completed"
    call.end_time = datetime.utcnow()
    if duration:
        try:
            call.duration_seconds = int(duration)
        except Exception:
            call.duration_seconds = None
    db_session.add(call)
    db_session.commit()
    db_session.refresh(call)

    # Use OpenAI client to extract structured readings
    res = openai_client.extract_readings_from_transcript(transcript)
    summary = res.get("summary") or ""
    readings = res.get("readings") or []
    call.summary = summary
    db_session.add(call)
    db_session.commit()

    # Persist readings
    for r in readings:
        import json
        reading_type = r.get("type") or r.get("reading_type") or "unknown"
        units = r.get("units")
        created_at = r.get("recorded_at")
        val_obj = {k: r[k] for k in r.keys() if k not in ("type", "units", "recorded_at")}
        rd = models.Reading(
            patient_id=call.patient_id or 0,
            call_id=call.id,
            reading_type=reading_type,
            value=json.dumps(val_obj),
            units=units,
            raw_text=str(r),
            recorded_at=created_at,
        )
        db_session.add(rd)
    db_session.commit()

    return {"ok": True, "summary": summary, "readings_count": len(readings)}


# --- Outbound endpoint: create DB row + ask Twilio to fetch TwiML from our /twiml/outbound/{call_id} ---
class OutboundCallCreate(BaseModel):
    org_id: int
    patient_id: Optional[int] = None
    to_number: str
    from_number: Optional[str] = None
    agent: Optional[str] = "annie_RPM"


@router.post("/outbound", response_model=schemas.CallOut)
def outbound_call(payload: OutboundCallCreate, db_session: Session = Depends(get_db)):
    """
    Create a call row and instruct Twilio to fetch TwiML from our /twiml/outbound/{call_id}.
    """
    # Validate org
    org = db_session.query(models.Organization).filter(models.Organization.id == payload.org_id).first()
    if not org:
        raise HTTPException(status_code=400, detail="Organization not found")

    # Create call DB row immediately
    call = models.Call(org_id=payload.org_id, patient_id=payload.patient_id, status="dialing")
    db_session.add(call)
    db_session.commit()
    db_session.refresh(call)

    # Twilio credentials from env
    TW_SID = os.getenv("TWILIO_ACCOUNT_SID")
    TW_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
    DEFAULT_FROM = os.getenv("TWILIO_FROM_NUMBER")
    if not (TW_SID and TW_TOKEN):
        call.status = "failed"
        db_session.add(call)
        db_session.commit()
        raise HTTPException(status_code=500, detail="Twilio credentials missing")

    from_number = payload.from_number or DEFAULT_FROM
    if not from_number:
        call.status = "failed"
        db_session.add(call)
        db_session.commit()
        raise HTTPException(status_code=400, detail="No from_number provided and TWILIO_FROM_NUMBER not set")

    # Build TwiML host/base
    twiml_host = os.getenv("TWIML_HOST")  # e.g., "abcd-1234.ngrok.io"
    if twiml_host:
        if twiml_host.startswith("http://") or twiml_host.startswith("https://"):
            base = twiml_host.rstrip("/")
        else:
            base = f"https://{twiml_host.rstrip('/')}"
    else:
        base = os.getenv("PUBLIC_BASE_URL", "").rstrip("/")
        if not base:
            call.status = "failed"
            db_session.add(call)
            db_session.commit()
            raise HTTPException(status_code=500, detail="TWIML_HOST or PUBLIC_BASE_URL environment variable must be set to a public URL Twilio can reach")

    # Build the TwiML URL (Twilio will GET/POST this URL)
    twiml_url = f"{base}/api/calls/twiml/outbound/{call.id}?agent={payload.agent}"

    # Create Twilio Call using 'Url' param (Twilio will fetch this URL)
    twilio_url = f"https://api.twilio.com/2010-04-01/Accounts/{TW_SID}/Calls.json"
    data = {
        "To": payload.to_number,
        "From": from_number,
        "Url": twiml_url,
    }

    try:
        resp = requests.post(twilio_url, auth=(TW_SID, TW_TOKEN), data=data, timeout=15)
    except Exception as e:
        call.status = "failed"
        db_session.add(call)
        db_session.commit()
        raise HTTPException(status_code=500, detail=f"Twilio request error: {str(e)}")

    if resp.status_code not in (200, 201):
        call.status = "failed"
        db_session.add(call)
        db_session.commit()
        raise HTTPException(status_code=500, detail=f"Twilio call failed: {resp.status_code} {resp.text}")

    j = resp.json()
    twilio_sid = j.get("sid")
    call.twilio_call_sid = twilio_sid
    call.status = "in_progress"
    db_session.add(call)
    db_session.commit()
    db_session.refresh(call)

    return call

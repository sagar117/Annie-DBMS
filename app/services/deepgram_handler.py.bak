# app/services/deepgram_handler.py
"""
Simple Deepgram <-> Twilio bridge WITHOUT any PCM conversion.
Forwards binary frames from Deepgram directly to Twilio as base64 in media.payload,
and forwards inbound Twilio media to Deepgram unchanged.

Expectations:
- Deepgram should be configured to output mulaw @ 8000 in the Settings message.
- bridge_ws(websocket, path_arg) used by app main should pass the FastAPI WebSocket object.
"""

import asyncio
import base64
import json
import os
from urllib.parse import urlparse, parse_qs
from datetime import datetime

import websockets
from websockets.exceptions import InvalidHandshake, ConnectionClosed

# Resolve prompts dir relative to project root
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
PROMPTS_DIR = os.path.join(BASE_DIR, "prompts")
DEFAULT_PROMPT_FILE = os.path.join(PROMPTS_DIR, "annie_RPM.txt")

DEEPGRAM_WS = "wss://agent.deepgram.com/v1/agent/converse"


def _extract_agent_from_path(path: str):
    if not path:
        return None
    try:
        parsed = urlparse(path)
        qs = parse_qs(parsed.query)
        vals = qs.get("agent") or qs.get("Agent") or qs.get("agent_name")
        if vals:
            return vals[0]
        # fallback: try path segmentation (legacy)
        parts = parsed.path.strip("/").split("/")
        if len(parts) >= 2 and parts[0].lower() == "twilio":
            seg = parts[1]
            safe = "".join(ch for ch in seg if (ch.isalnum() or ch in ("-", "_")))
            return safe or None
    except Exception:
        return None
    return None


def prompt_file_for_agent(agent_name: str):
    if not agent_name:
        return DEFAULT_PROMPT_FILE
    safe = "".join(ch for ch in agent_name if (ch.isalnum() or ch in ("-", "_")))
    candidate = os.path.join(PROMPTS_DIR, f"{safe}.txt")
    if os.path.isfile(candidate):
        return candidate
    return DEFAULT_PROMPT_FILE


def load_prompt(file_path: str) -> str:
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            return f.read().strip()
    except Exception:
        return ""


def sts_connect():
    api_key = os.getenv("DEEPGRAM_API_KEY")
    if not api_key:
        raise RuntimeError("DEEPGRAM_API_KEY environment variable is not set")
    return websockets.connect(DEEPGRAM_WS, subprotocols=["token", api_key])


async def bridge_ws(ws, path_arg: str = None):
    """
    Bridge function for FastAPI WebSocket.
    - ws: FastAPI WebSocket instance (has send_text, receive, etc.)
    - path_arg: original request path (ex: "/ws?agent=annie_RPM&call_id=123")
    """
    agent = _extract_agent_from_path(path_arg)
    prompt_path = prompt_file_for_agent(agent)
    prompt_text = load_prompt(prompt_path)
    print(f"[deepgram bridge] agent={agent} prompt={prompt_path}")

    audio_queue = asyncio.Queue()      # bytes to send to Deepgram
    streamsid_queue = asyncio.Queue()  # streamSid from Twilio start event
    should_hangup = asyncio.Event()

    # small helper to persist debug info to call.summary (best effort)
    def persist_debug_event(ev: dict):
        try:
            from app import db, models
            qs = parse_qs(path_arg or "")
            vals = qs.get("call_id") or qs.get("CallId") or qs.get("call")
            if not vals:
                return
            call_id = int(vals[0])
            session = db.SessionLocal()
            try:
                call_row = session.query(models.Call).filter(models.Call.id == call_id).first()
                if call_row:
                    short = json.dumps(ev)[:2000]
                    call_row.summary = (call_row.summary or "") + "\n[DBG] " + short
                    session.add(call_row)
                    session.commit()
            finally:
                session.close()
        except Exception as e:
            print("[persist_debug_event] failed:", repr(e))

    try:
        async with sts_connect() as sts_ws:
            # Request mu-law @ 8000 from Deepgram
            config_message = {
                "type": "Settings",
                "audio": {
                    "input": {"encoding": "mulaw", "sample_rate": 8000},
                    "output": {"encoding": "mulaw", "sample_rate": 8000, "container": "none"},
                },
                "agent": {
                    "language": "en",
                    "listen": {"provider": {"type": "deepgram", "model": "nova-3"}},
                    "think": {
                        "provider": {"type": "open_ai", "model": "gpt-4o-mini", "temperature": 0.3},
                        "prompt": prompt_text or "You are a helpful AI nurse helping patient answer their query",
                    },
                    "speak": {"provider": {"type": "deepgram", "model": "aura-2-thalia-en"}},
                    "greeting": "Hello",
                },
            }
            await sts_ws.send(json.dumps(config_message))
            print("[bridge_ws] sent Deepgram Settings")

            # send binary chunks to Deepgram
            async def sts_sender():
                try:
                    while True:
                        chunk = await audio_queue.get()
                        if chunk is None:
                            break
                        try:
                            await sts_ws.send(chunk)
                        except ConnectionClosed:
                            break
                        except Exception as e:
                            print("[sts_sender] send failed:", repr(e))
                            break
                except Exception as e:
                    print("[sts_sender] unexpected:", repr(e))

            # receive from Deepgram and forward to Twilio (no conversion)
            async def sts_receiver():
                try:
                    # wait for Twilio streamSid (blocks until start)
                    try:
                        streamsid = await streamsid_queue.get()
                    except Exception:
                        streamsid = None

                    async for message in sts_ws:
                        # text events (JSON)
                        if isinstance(message, str):
                            try:
                                decoded = json.loads(message)
                            except Exception:
                                decoded = {"raw": message}
                            ev_type = decoded.get("type", "")
                            # minimal logging
                            print(f"[deepgram event] type={ev_type} keys={list(decoded.keys())}")
                            # persist conversation text if present
                            if ev_type == "ConversationText":
                                role = decoded.get("role")
                                content = decoded.get("content") or decoded.get("text") or ""
                                print(f"[deepgram conv] role={role} text={content[:200]}")
                                try:
                                    from app import db, models
                                    qs = parse_qs(path_arg or "")
                                    vals = qs.get("call_id") or qs.get("CallId") or qs.get("call")
                                    call_id = int(vals[0]) if vals else None
                                    if call_id:
                                        session = db.SessionLocal()
                                        try:
                                            call_row = session.query(models.Call).filter(models.Call.id == call_id).first()
                                            if call_row:
                                                call_row.transcript = (call_row.transcript or "") + f"\n[{role}] " + content
                                                session.add(call_row)
                                                session.commit()
                                        finally:
                                            session.close()
                                except Exception:
                                    pass
                            continue

                        # binary frames -> forward raw as base64 to Twilio
                        try:
                            raw = bytes(message)
                            size = len(raw)
                            print(f"[sts_receiver] received binary frame size={size} bytes; streamSid={streamsid}")
                            payload_b64 = base64.b64encode(raw).decode("ascii")
                            media_message = {
                                "event": "media",
                                "streamSid": streamsid or "",
                                "media": {"payload": payload_b64},
                            }
                            # use compact JSON to avoid extra spaces
                            try:
                                await ws.send_text(json.dumps(media_message, separators=(",", ":")))
                                print("[sts_receiver] forward OK")
                            except Exception as fe:
                                print("[sts_receiver] forward FAILED:", repr(fe))
                                persist_debug_event({"error": "forward_failed", "detail": str(fe)})
                        except Exception as e:
                            print("[sts_receiver] error handling binary:", repr(e))

                except Exception as e:
                    print("[sts_receiver] unexpected outer:", repr(e))

            # receive Twilio WebSocket, forward inbound audio to Deepgram
            async def twilio_receiver():
                BUFFER_SIZE = 5 * 160
                inbuffer = bytearray()
                try:
                    while True:
                        msg = await ws.receive()
                        mtype = msg.get("type")
                        if mtype == "websocket.disconnect":
                            print("[twilio_receiver] websocket.disconnect")
                            break

                        text = msg.get("text")
                        data = None
                        if text is not None:
                            try:
                                data = json.loads(text)
                            except Exception:
                                continue
                        else:
                            b = msg.get("bytes")
                            if b:
                                try:
                                    data = json.loads(b.decode("utf-8", errors="ignore"))
                                except Exception:
                                    continue

                        if not data:
                            continue

                        evt = data.get("event")
                        if evt == "start":
                            start = data.get("start", {})
                            streamsid = start.get("streamSid")
                            if streamsid:
                                print(f"[twilio_receiver] received start streamSid={streamsid}")
                                streamsid_queue.put_nowait(streamsid)
                                # persist call start_time
                                try:
                                    from app import db, models
                                    qs = parse_qs(path_arg or "")
                                    vals = qs.get("call_id") or qs.get("CallId") or qs.get("call")
                                    call_id = int(vals[0]) if vals else None
                                    if call_id:
                                        session = db.SessionLocal()
                                        try:
                                            call_row = session.query(models.Call).filter(models.Call.id == call_id).first()
                                            if call_row and not call_row.start_time:
                                                call_row.start_time = datetime.utcnow()
                                                call_row.status = "in_progress"
                                                session.add(call_row)
                                                session.commit()
                                        finally:
                                            session.close()
                                except Exception:
                                    pass
                        elif evt == "media":
                            media = data.get("media", {})
                            payload_b64 = media.get("payload", "")
                            if not payload_b64:
                                continue
                            chunk = base64.b64decode(payload_b64)
                            if media.get("track") == "inbound":
                                inbuffer.extend(chunk)
                            while len(inbuffer) >= BUFFER_SIZE:
                                try:
                                    await audio_queue.put(bytes(inbuffer[:BUFFER_SIZE]))
                                except Exception:
                                    pass
                                del inbuffer[:BUFFER_SIZE]
                        elif evt == "stop":
                            print("[twilio_receiver] received stop")
                            # persist end_time and duration
                            try:
                                from app import db, models
                                qs = parse_qs(path_arg or "")
                                vals = qs.get("call_id") or qs.get("CallId") or qs.get("call")
                                call_id = int(vals[0]) if vals else None
                                if call_id:
                                    session = db.SessionLocal()
                                    try:
                                        call_row = session.query(models.Call).filter(models.Call.id == call_id).first()
                                        if call_row:
                                            call_row.end_time = datetime.utcnow()
                                            call_row.status = "completed"
                                            if call_row.start_time:
                                                call_row.duration_seconds = int((call_row.end_time - call_row.start_time).total_seconds())
                                            session.add(call_row)
                                            session.commit()
                                    finally:
                                        session.close()
                            except Exception:
                                pass
                            break

                        if should_hangup.is_set():
                            break
                except Exception as e:
                    print("[twilio_receiver] unexpected:", repr(e))
                finally:
                    try:
                        await audio_queue.put(None)
                    except Exception:
                        try:
                            audio_queue.put_nowait(None)
                        except Exception:
                            pass

            sender_task = asyncio.create_task(sts_sender())
            receiver_task = asyncio.create_task(sts_receiver())
            twilio_task = asyncio.create_task(twilio_receiver())

            done, pending = await asyncio.wait(
                [sender_task, receiver_task, twilio_task],
                return_when=asyncio.FIRST_COMPLETED,
            )
            for t in pending:
                t.cancel()

    except InvalidHandshake as e:
        print("[bridge_ws] deepgram handshake failed:", repr(e))
        persist_debug_event({"error": "deepgram_handshake", "detail": str(e)})
    except Exception as e:
        print("[bridge_ws] error:", repr(e))
        persist_debug_event({"error": "bridge_ws_exception", "detail": str(e)})
    finally:
        try:
            await ws.close()
        except Exception:
            pass

# app/main.py
import logging
import json
from typing import Optional

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware

# Import routers if available in your project
try:
    from app.api import calls, patients, orgs  # noqa: F401
except Exception:
    calls = None
    patients = None
    orgs = None

logger = logging.getLogger("annie.main")
logging.basicConfig(level=logging.INFO)

app = FastAPI(title="Annie Backend")

# CORS (adjust origins as required)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# include routers if they exist
if calls is not None:
    try:
        app.include_router(calls.router)
    except Exception:
        pass
if patients is not None:
    try:
        app.include_router(patients.router)
    except Exception:
        pass
if orgs is not None:
    try:
        app.include_router(orgs.router)
    except Exception:
        pass

@app.get("/health")
def health():
    return {"status": "ok"}


# Robust websocket endpoint:
# Accept both /ws and /ws/<anything...> and preserve raw_path (percent-encoded parts).
@app.websocket("/ws")
@app.websocket("/ws/{tail:path}")
async def websocket_endpoint(websocket: WebSocket, tail: str = ""):
    """
    WebSocket endpoint that preserves the full raw ASGI path and querystring, then
    delegates to bridge_ws(ws, path_arg).
    This ensures percent-encoded segments (like call_id%3D70) are preserved.
    """
    await websocket.accept()

    # Build raw path_arg from ASGI scope to preserve percent-encoding + querystring
    try:
        raw_path = websocket.scope.get("raw_path")
        if isinstance(raw_path, (bytes, bytearray)):
            raw_path = raw_path.decode("utf-8", errors="ignore")
        if not raw_path:
            raw_path = websocket.scope.get("path", "/ws")
        raw_qs = websocket.scope.get("query_string", b"")
        if raw_qs:
            try:
                qs = raw_qs.decode("utf-8", errors="ignore")
                path_arg = raw_path + "?" + qs
            except Exception:
                path_arg = raw_path
        else:
            path_arg = raw_path
    except Exception:
        path_arg = "/ws"

    logger.info("WebSocket connected: path_arg=%s", path_arg)

    # Import bridge lazily (so we don't create circular import problems)
    try:
        from app.services.deepgram_handler import bridge_ws  # type: ignore
    except Exception as e:
        logger.exception("bridge_ws import failed: %s", e)
        bridge_ws = None

    if bridge_ws is None:
        try:
            await websocket.send_text(json.dumps({"error": "bridge_ws_unavailable"}))
        except Exception:
            pass
        await websocket.close()
        return

    try:
        await bridge_ws(websocket, path_arg)
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected (client)")
        try:
            await websocket.close()
        except Exception:
            pass
    except Exception as e:
        logger.exception("Error in bridge_ws: %s", e)
        try:
            await websocket.close()
        except Exception:
            pass
